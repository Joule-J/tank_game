<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Tanks — TRON Neon</title>
  <style>
    :root{
      --bg1:#06070b; --bg2:#0a0f1e;
      --panel:#0a0f1e; --panel2:#0b1226;
      --text:#e6fbff; --muted:#7cc7d9; --acc:#00f0ff; --acc2:#00ffa3; --danger:#ff4d88; --ok:#00ffa3
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;
      color:var(--text); display:flex; background:radial-gradient(1200px 800px at 20% 10%, #0e2740 0%, #07101e 40%, #05070d 100%);
    }
    .sidebar{width:420px;max-width:100%;padding:16px;background:linear-gradient(180deg,var(--panel),var(--panel2));border-right:1px solid #0f2547;overflow:auto;box-shadow:inset -8px 0 24px rgba(0,240,255,.05)}
    .brand{font-weight:900;letter-spacing:.5px;font-size:20px;display:flex;align-items:center;gap:8px;text-shadow:0 0 8px rgba(0,240,255,.6)}
    .brand .dot{width:10px;height:10px;background:var(--acc);border-radius:2px;box-shadow:0 0 18px var(--acc)}
    .section{margin-top:16px;padding-top:12px;border-top:1px dashed rgba(0,240,255,.25)}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button,select,input[type="text"],textarea,.btn{
      background:#0b142b;color:var(--text);border:1px solid rgba(0,240,255,.3);padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:700;
      box-shadow:0 0 10px rgba(0,240,255,.08) inset, 0 0 8px rgba(0,240,255,.08);
    }
    textarea{width:100%;min-height:90px;resize:vertical}
    button:hover,.btn:hover{filter:brightness(1.15)}
    .btn-ghost{background:transparent;border:1px dashed rgba(0,240,255,.35);color:var(--muted)}
    .note{font-size:12px;color:var(--muted)}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#07101e;border:1px solid rgba(0,240,255,.25);padding:2px 6px;border-radius:6px;box-shadow:0 0 10px rgba(0,240,255,.08) inset}
    .swatch{width:18px;height:18px;border-radius:4px;border:1px solid rgba(255,255,255,.25);cursor:pointer;box-shadow:0 0 10px rgba(255,255,255,.08)}
    canvas{
      image-rendering:pixelated;background:linear-gradient(180deg,#02050a,#030812);
      border-radius:0; box-shadow:0 0 40px rgba(0,240,255,.25), inset 0 0 24px rgba(0,240,255,.06); border:1px solid rgba(0,240,255,.25)
    }
    .main{flex:1;display:flex;padding:16px}
    .stage{margin:auto;display:flex;flex-direction:column;gap:8px;align-items:center}
    .bar{display:flex;gap:8px;align-items:center;justify-content:center;width:100%}
    .pill{background:#07101e;border:1px solid rgba(0,240,255,.35);padding:8px 12px;border-radius:999px;color:var(--text);font-size:13px;box-shadow:0 0 10px rgba(0,240,255,.08) inset}
    .grid-legend{display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:12px}
    .small{font-size:12px;color:var(--muted)}
    .ok{color:#b7ffcf}
    .players{display:flex;flex-direction:column;gap:8px}
    .playerRow{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <aside class="sidebar">
    <div class="brand"><span class="dot"></span> Pixel Tanks — <span style="color:var(--acc)">NEON</span></div>

    <div class="section">
      <h4>Oyuncular (2-4)</h4>
      <div class="players" id="playersList"></div>
      <div class="row">
        <input id="newPlayerName" type="text" placeholder="Oyuncu adı" />
        <select id="newPlayerColor"></select>
        <button id="btnAddPlayer">Oyuncu Ekle</button>
      </div>
      <p class="note">İlk iki oyuncu yerelde kontrol edilir (P1: WASD+Mouse, P2: IJKL/UO/;). Diğerleri ağ ile bağlanır.</p>
    </div>

    <div class="section">
      <h4>Oyun Modu</h4>
      <div class="row">
        <button id="btnPlay">Yerel VS</button>
        <button id="btnEditor">Harita Editörü</button>
      </div>
      <p class="note">Çevrimiçi: Oda kur → kodu paylaş → oyuncular katılsın. Host cihazı sunucudur.</p>
    </div>

    <div class="section">
      <h4>Harita Seç</h4>
      <div class="row">
        <select id="mapSelect"></select>
        <button id="btnResetScores" class="btn-ghost">Skorları Sıfırla</button>
      </div>
    </div>

    <div class="section">
      <h4>Kontroller</h4>
      <div class="grid-legend">
        <div><b>Oyuncu 1</b><br><span class="small"><span class="kbd">WASD</span> hareket • <b>Fare</b> nişan • <b>Sol tık</b> ateş</span></div>
        <div><b>Oyuncu 2</b><br><span class="small"><span class="kbd">IJKL</span> hareket • <span class="kbd">U/O</span> kule • <span class="kbd">;</span> ateş</span></div>
      </div>
      <p class="note">Mermi duvarlardan en fazla 2 kez seker. Dergi: 5 mermi, her eksik mermi <b>2.0s</b> sonra dolar. Doğuşta <b>3 mermi</b>.</p>
    </div>

    <div class="section">
      <h4>Editör</h4>
      <p class="small">Sol tık: duvar ekle/kaldır • <span class="kbd">R</span>: yerleştir/sil • <span class="kbd">S</span>: kaydet • <span class="kbd">X</span>: temizle • <span class="kbd">G</span>: ızgara aç/kapa</p>
      <div class="row">
        <input id="mapName" type="text" placeholder="Yeni harita adı" />
        <button id="btnSaveMap">Kaydet</button>
        <button id="btnExport" class="btn-ghost">Dışa Aktar</button>
        <button id="btnImport" class="btn-ghost">İçe Aktar</button>
      </div>
    </div>

    <div class="section">
      <h4>Online Oda</h4>
      <div class="row">
        <input id="roomName" type="text" placeholder="Oda adı" />
        <input id="roomPass" type="text" placeholder="Şifre (opsiyonel)" />
      </div>
      <div class="row">
        <button id="btnRoomCreate">Oda Kur</button>
        <button id="btnRoomAddGuest" class="btn-ghost">Yeni Misafir Slotu</button>
      </div>
      <div class="row">
        <textarea id="roomOffer" placeholder="Oda Kodu (Host oluşturur)"></textarea>
        <textarea id="roomAnswer" placeholder="Yanıt Kodu (Misafir oluşturur)"></textarea>
      </div>
      <div class="row">
        <button id="btnCopyRoom" class="btn-ghost">Kodu Kopyala</button>
        <button id="btnApplyAnswer" class="btn-ghost">Yanıtı Uygula</button>
        <button id="btnJoinRoom" class="btn">Odaya Katıl</button>
        <button id="btnMakeAnswer" class="btn-ghost">Yanıt Oluştur</button>
      </div>
      <p class="note">Akış: Host <b>Oda Kur</b> (ad + şifre ile anahtar oluşturur) → kodu paylaşır. Misafir <b>Odaya Katıl</b> (aynı ad+şifre) → <b>Yanıt Oluştur</b> → host <b>Yanıtı Uygula</b>. Anahtar uyuşmazsa bağlantı reddedilir.</p>
    </div>

  </aside>

  <main class="main">
    <div class="stage">
      <div class="bar">
        <span class="pill" id="status">Hazır</span>
        <span class="pill" id="score">—</span>
        <span class="pill" id="ammo">P1 Ammo: 3/5</span>
      </div>
      <canvas id="game" width="960" height="640"></canvas>
      <div class="bar">
        <button id="btnPause" class="btn">Duraklat</button>
        <button id="btnRestart" class="btn">Yeniden Başlat</button>
      </div>
    </div>
  </main>

  <script>
  // ======= Utility =======
  const TILE=32, COLS=30, ROWS=20;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now();
  function blankGrid(){return Array.from({length:ROWS},()=>Array(COLS).fill(0));}
  function copyGrid(g){return g.map(r=>r.slice())}
  const rand=(a,b)=>Math.random()*(b-a)+a;

  // ======= Colors (8 seçenek) =======
  const COLORS=['#00FFA3','#00E5FF','#FF6EC7','#FFD166','#8AFF00','#FF4D88','#A78BFA','#00FFD1'];

  // ======= Maps =======
  const MAPS={
    "Boxed Arena":(()=>{const g=blankGrid();
      for(let x=0;x<COLS;x++){g[0][x]=1;g[ROWS-1][x]=1}
      for(let y=0;y<ROWS;y++){g[y][0]=1;g[y][COLS-1]=1}
      for(let x=10;x<20;x++) g[Math.floor(ROWS/2)][x]=1;
      for(let y=6;y<14;y++) g[y][Math.floor(COLS/2)]=1; return g;})(),
    "Corridors":(()=>{const g=blankGrid();
      for(let x=0;x<COLS;x++){g[0][x]=1;g[ROWS-1][x]=1}
      for(let y=0;y<ROWS;y++){g[y][0]=1;g[y][COLS-1]=1}
      for(let y=2;y<ROWS-2;y+=4){for(let x=2;x<COLS-2;x++) g[y][x]=1}
      for(let x=4;x<COLS-4;x+=6){for(let y=4;y<ROWS-4;y++) g[y][x]=1} return g;})(),
    "Islands":(()=>{const g=blankGrid();
      for(let x=0;x<COLS;x++){g[0][x]=1;g[ROWS-1][x]=1}
      for(let y=0;y<ROWS;y++){g[y][0]=1;g[y][COLS-1]=1}
      const blocks=[[6,5,4,3],[18,5,5,4],[10,12,6,3],[20,12,5,4]];
      for(const [sx,sy,w,h] of blocks){for(let y=sy;y<sy+h;y++){for(let x=sx;x<sx+w;x++){g[y][x]=1}}} return g;})()
  };

  function loadCustomMaps(){try{return JSON.parse(localStorage.getItem('pixelTanksMaps')||"{}");}catch{return {}}}
  function saveCustomMaps(obj){localStorage.setItem('pixelTanksMaps',JSON.stringify(obj))}

  // ======= Canvas =======
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');
  ctx.imageSmoothingEnabled=false;

  // ======= Game State =======
  let currentMapName=Object.keys(MAPS)[0];
  let customMaps=loadCustomMaps();
  let grid=copyGrid(MAPS[currentMapName]);
  let playing=true, paused=false;
  let keys=new Set();
  let bullets=[], tanks=[], score=[];
  let editorMode=false, editorPaint=1, showGrid=true;
  let mouse={x:canvas.width/2,y:canvas.height/2,down:false};

  // Networking (oda/host)
  let role='solo'; // 'host' | 'guest' | 'solo'
  let hostPeers=[]; // [{pc,dc,slot}]
  let guestPC=null, guestDC=null;

  const AMMO_MAX=5, AMMO_RELOAD_MS=2000, FIRE_CD_MS=250, RESPAWN_INV_MS=2000, RESPAWN_DELAY_MS=400, SPAWN_AMMO=3;

  function makeTank(color,x,y,angle,name){
    return{ name, color, x, y, angle, turret:angle, vx:0, vy:0, speed:2.2, size:24,
      alive:true, spawnTimer:0, ammo:SPAWN_AMMO, ammoAcc:0, invulnUntil:0 }
  }

  function setDefaultPlayers(){
    tanks=[
      makeTank(COLORS[0], TILE*2, TILE*2, 0, 'Player 1'),
      makeTank(COLORS[1], canvas.width-TILE*2, canvas.height-TILE*2, Math.PI, 'Player 2')
    ];
    score=[0,0];
  }

  // ==== SPAWN LOGIC (rastgele & birbirinden uzak) ====
  function freeTiles(){
    const arr=[];
    for(let y=1;y<ROWS-1;y++){
      for(let x=1;x<COLS-1;x++){
        if(grid[y][x]!==1){
          let ok=true; for(let yy=y-1;yy<=y+1;yy++){ for(let xx=x-1;xx<=x+1;xx++){ if(grid[yy]?.[xx]===1) ok=false; }}
          if(ok) arr.push({x:x*TILE+TILE/2, y:y*TILE+TILE/2});
        }
      }
    }
    return arr;
  }
  function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}
  function bestSpawnFor(idx){
    const candidates=freeTiles(); if(candidates.length===0) return {x:TILE*2,y:TILE*2};
    const existing=tanks.filter((t,i)=>i!==idx && t && t.alive);
    const sample=[]; for(let i=0;i<Math.min(300,candidates.length);i++){ sample.push(candidates[(Math.random()*candidates.length)|0]); }
    const scored=sample.map(p=>({p,score:existing.length? Math.min(...existing.map(e=>dist(p,e))) : 99999}));
    scored.sort((a,b)=>b.score-a.score);
    const top=Math.max(1,Math.floor(scored.length*0.1));
    const pick=scored[(Math.random()*top)|0].p;
    return {x:pick.x,y:pick.y};
  }

  function respawnAtBest(idx){
    const pos=bestSpawnFor(idx);
    Object.assign(tanks[idx],{x:pos.x,y:pos.y,alive:true,spawnTimer:FIRE_CD_MS*2,invulnUntil:now()+RESPAWN_INV_MS,ammo:SPAWN_AMMO,ammoAcc:0});
  }

  function addPlayerUIRow(name="Player", color=COLORS[ (Math.random()*COLORS.length)|0 ]){
    const list=document.getElementById('playersList');
    if(list.children.length>=4){ alert('Maksimum 4 oyuncu'); return; }
    const row=document.createElement('div'); row.className='playerRow';
    const nameI=document.createElement('input'); nameI.type='text'; nameI.value=name; nameI.placeholder='Oyuncu adı';
    const colorSel=document.createElement('select');
    COLORS.forEach((c,i)=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; o.style.background=c; if(c===color) o.selected=true; colorSel.appendChild(o); });
    const btnDel=document.createElement('button'); btnDel.textContent='Sil';
    row.appendChild(nameI); row.appendChild(colorSel); row.appendChild(btnDel); list.appendChild(row);
    btnDel.onclick=()=>{ list.removeChild(row); rebuildPlayersFromUI(); };
    nameI.onchange=colorSel.onchange=()=>rebuildPlayersFromUI();
  }

  function rebuildPlayersFromUI(){
    const list=document.getElementById('playersList');
    const rows=[...list.querySelectorAll('.playerRow')];
    while(rows.length<2) { addPlayerUIRow('Player '+(rows.length+1), COLORS[rows.length%COLORS.length]); rows.push(...list.querySelectorAll('.playerRow')); }
    if(rows.length>4){ while(list.children.length>4) list.removeChild(list.lastChild); }
    const old=tanks; tanks=[]; score=[];
    rows.slice(0,4).forEach((r,idx)=>{
      const name=r.querySelector('input').value||('Player '+(idx+1));
      const color=r.querySelector('select').value||COLORS[idx%COLORS.length];
      const t=makeTank(color, TILE*2+idx*40, TILE*2+idx*40, 0, name);
      tanks.push(t); score.push(0);
    });
    tanks.forEach((_,i)=>{ respawnAtBest(i); });
    updateScore(); draw();
  }

  (function initPlayersUI(){ addPlayerUIRow('Player 1', COLORS[0]); addPlayerUIRow('Player 2', COLORS[1]); })();

  function resetGame(){
    grid=copyGrid((MAPS[currentMapName]||customMaps[currentMapName]));
    bullets=[];
    const pl=document.getElementById('playersList');
    if(pl.children.length<2){ setDefaultPlayers(); }
    else { rebuildPlayersFromUI(); }
    tanks.forEach((t,i)=>{ t.alive=true; t.invulnUntil=0; t.ammo=SPAWN_AMMO; t.ammoAcc=0; const pos=bestSpawnFor(i); t.x=pos.x; t.y=pos.y; });
    updateHud();
  }

  function aabbWall(x,y,sz){
    const left=Math.floor((x-sz/2)/TILE), right=Math.floor((x+sz/2)/TILE);
    const top=Math.floor((y-sz/2)/TILE), bottom=Math.floor((y+sz/2)/TILE);
    for(let ty=top;ty<=bottom;ty++){
      for(let tx=left;tx<=right;tx++){
        if(ty<0||ty>=ROWS||tx<0||tx>=COLS) return {hit:true,tx,ty};
        if(grid[ty][tx]===1) return {hit:true,tx,ty};
      }
    }
    return {hit:false};
  }

  function spawnBullet(ownerIdx,x,y,dir){
    bullets.push({
      owner:ownerIdx, x, y,
      vx:Math.cos(dir)*5, vy:Math.sin(dir)*5,
      bounces:0, maxB:2, alive:true,
      trail:[], age:0,
      trailMin:8, trailBase:12, trailInitial:28,
      bounceBoost:0, bounceBoostMax:500,
    });
  }

  function handleKill(killerIdx,victimIdx){
    const killer=tanks[killerIdx], victim=tanks[victimIdx];
    if(!victim || !victim.alive) return;
    victim.alive=false; bullets.forEach(b=>{ if(b.owner===victimIdx) b.alive=false; });
    score[killerIdx] = (score[killerIdx]||0)+1; updateScore();
    setTimeout(()=>{ respawnAtBest(victimIdx); updateHud(); }, RESPAWN_DELAY_MS);
  }

  function update(dt){
    if(role==='guest'){ updateHud(); return; }
    if(!playing||paused) { updateHud(); return; }

    const p1=tanks[0];
    if(p1&&p1.alive){
      const ax=(keys.has('KeyD')?1:0)-(keys.has('KeyA')?1:0);
      const ay=(keys.has('KeyS')?1:0)-(keys.has('KeyW')?1:0);
      const mag=Math.hypot(ax,ay), nx=mag?ax/mag:0, ny=mag?ay/mag:0;
      p1.vx=nx*p1.speed; p1.vy=ny*p1.speed;
      p1.x+=p1.vx; if(aabbWall(p1.x,p1.y,p1.size).hit) p1.x-=p1.vx;
      p1.y+=p1.vy; if(aabbWall(p1.x,p1.y,p1.size).hit) p1.y-=p1.vy;
      p1.turret=Math.atan2(mouse.y-p1.y,mouse.x-p1.x);
      p1.spawnTimer=Math.max(0,p1.spawnTimer-dt);
      if(p1.ammo<AMMO_MAX){ p1.ammoAcc+=dt; while(p1.ammo<AMMO_MAX && p1.ammoAcc>=AMMO_RELOAD_MS){ p1.ammo++; p1.ammoAcc-=AMMO_RELOAD_MS; } }
      if(mouse.down && p1.spawnTimer<=0 && p1.ammo>0){ p1.spawnTimer=FIRE_CD_MS; p1.ammo--; spawnBullet(0,p1.x,p1.y,p1.turret); }
    }

    for(let i=1;i<tanks.length;i++){
      const p=tanks[i]; if(!p||!p.alive) continue;
      const r=p._remote; let ax=0, ay=0, fire=false, aim=null;
      if(r){
        ax=(r.keys?.includes('KeyD')?1:0)-(r.keys?.includes('KeyA')?1:0);
        ay=(r.keys?.includes('KeyS')?1:0)-(r.keys?.includes('KeyW')?1:0);
        aim=r.mouse; fire=r.fire;
      } else if(i===1){
        ax=(keys.has('KeyL')?1:0)-(keys.has('KeyJ')?1:0);
        ay=(keys.has('KeyK')?1:0)-(keys.has('KeyI')?1:0);
        if(keys.has('KeyU')) p.turret-=0.05; if(keys.has('KeyO')) p.turret+=0.05;
        fire=keys.has('Semicolon');
      }
      const mag=Math.hypot(ax,ay), nx=mag?ax/mag:0, ny=mag?ay/mag:0;
      p.vx=nx*p.speed; p.vy=ny*p.speed;
      p.x+=p.vx; if(aabbWall(p.x,p.y,p.size).hit) p.x-=p.vx;
      p.y+=p.vy; if(aabbWall(p.x,p.y,p.size).hit) p.y-=p.vy;
      if(aim){ p.turret=Math.atan2(aim.y-p.y,aim.x-p.x); }
      p.spawnTimer=Math.max(0,p.spawnTimer-dt);
      if(p.ammo<AMMO_MAX){ p.ammoAcc+=dt; while(p.ammo<AMMO_MAX && p.ammoAcc>=AMMO_RELOAD_MS){ p.ammo++; p.ammoAcc-=AMMO_RELOAD_MS; } }
      if(fire && p.spawnTimer<=0 && p.ammo>0){ p.spawnTimer=FIRE_CD_MS; p.ammo--; spawnBullet(i,p.x,p.y,p.turret); }
    }

    for(const b of bullets){ if(!b.alive) continue;
      b.age += dt;
      const t = Math.min(1, Math.max(0, b.age/900));
      const easeOut = 1 - (1 - t) * (1 - t);
      let trailTarget = b.trailInitial * (1 - easeOut) + b.trailBase * easeOut;
      if(b.bounceBoost>0){ const k=b.bounceBoost/b.bounceBoostMax; trailTarget += 12*k; b.bounceBoost -= dt; }
      trailTarget = Math.max(b.trailMin, Math.min(32, trailTarget));
      b.trail.push({x:b.x,y:b.y}); while(b.trail.length > Math.floor(trailTarget)) b.trail.shift();
      b.x+=b.vx; b.y+=b.vy;
      const cx=Math.floor(b.x/TILE), cy=Math.floor(b.y/TILE);
      if(cy<0||cy>=ROWS||cx<0||cx>=COLS||grid[cy][cx]===1){
        const prevX=b.x-b.vx, prevY=b.y-b.vy;
        const cellX=Math.floor(prevX/TILE), cellY=Math.floor(prevY/TILE);
        const hitX=(cellY<0||cellY>=ROWS||cx<0||cx>=COLS||grid[cellY][cx]===1);
        const hitY=(cy<0||cy>=ROWS||cellX<0||cellX>=COLS||grid[cy][cellX]===1);
        if(hitX) b.vx*=-1; if(hitY) b.vy*=-1;
        b.bounces++; if(b.bounces>b.maxB){ b.alive=false; continue }
        b.bounceBoost = b.bounceBoostMax; b.trailInitial = Math.min(30, Math.max(b.trailInitial, b.trailBase + 10));
        b.x=prevX+b.vx*0.5; b.y=prevY+b.vy*0.5;
      }
      for(let i=0;i<tanks.length;i++){
        const tnk=tanks[i]; if(!tnk||!tnk.alive||i===b.owner) continue; if(now()<tnk.invulnUntil) continue;
        if(Math.hypot(b.x-tnk.x,b.y-tnk.y)<tnk.size*0.55){ b.alive=false; handleKill(b.owner,i); }
      }
    }
    bullets=bullets.filter(b=>b.alive);

    if(role==='host' && hostPeers.length){
      const t=tanks.map(t=>({x:t.x,y:t.y,turret:t.turret,alive:t.alive,inv:t.invulnUntil,ammo:t.ammo,name:t.name,color:t.color}));
      const msg=JSON.stringify({type:'state', t, s:score});
      hostPeers.forEach(({dc})=>{ if(dc && dc.readyState==='open'){ try{ dc.send(msg); }catch{} } });
    }

    updateHud();
  }

  function updateScore(){ const parts=tanks.map((t,i)=>`${t.name} ${score[i]||0}`).join('  •  '); scoreEl.textContent=parts||'—'; }
  function updateHud(){ ammoEl.textContent=`P1 Ammo: ${tanks[0]?tanks[0].ammo:0}/${AMMO_MAX}`; }

  function draw(){
    ctx.fillStyle='#03060d'; ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<canvas.height;y+=4){ ctx.fillStyle='rgba(0,240,255,0.03)'; ctx.fillRect(0,y,canvas.width,1); }

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const px=x*TILE, py=y*TILE;
        if(grid[y][x]===1){
          ctx.fillStyle='rgba(0,240,255,0.14)'; ctx.fillRect(px-2,py-2,TILE+4,TILE+4);
          ctx.fillStyle='#082238'; ctx.fillRect(px,py,TILE,TILE);
          ctx.strokeStyle='rgba(0,240,255,0.7)'; ctx.lineWidth=2; ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
        } else if(showGrid){
          ctx.fillStyle='rgba(0,240,255,0.05)'; ctx.fillRect(px,py,TILE,1); ctx.fillRect(px,py,1,TILE);
        }
      }
    }

    for(const b of bullets){
      const owner=tanks[b.owner]; const neon=owner?owner.color:'#00f0ff';
      const rgb=hexToRgb(neon);
      for(let i=0;i<b.trail.length-1;i++){
        const p=b.trail[i], q=b.trail[i+1];
        const a=i/(b.trail.length-1);
        const pulse = 0.6 + 0.4*Math.sin((b.age/90) + i*0.3);
        const alpha = 0.08 + 0.28*a*pulse;
        ctx.strokeStyle=`rgba(${rgb},${alpha})`;
        ctx.lineWidth=1 + 2.5*(1-a)*pulse;
        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
      }
    }

    for(const b of bullets){ const owner=tanks[b.owner]; const neon=owner?owner.color:'#00f0ff';
      ctx.fillStyle=`rgba(${hexToRgb(neon)},0.4)`; ctx.beginPath(); ctx.arc(b.x,b.y,6,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=neon; ctx.fillRect(b.x-2,b.y-2,4,4);
    }

    for(let idx=0; idx<tanks.length; idx++){
      const t=tanks[idx]; if(!t.alive) continue; const s=t.size; const blinking=(now()<t.invulnUntil)&&Math.floor(now()/150)%2===0;
      const neon=t.color; const glow = blinking? 'rgba(255,255,255,0.25)' : `${neon}80`;
      ctx.fillStyle=glow; ctx.fillRect(t.x-s/2-4,t.y-s/2-4,s+8,s+8);
      ctx.fillStyle='#06101c'; ctx.fillRect(t.x-s/2,t.y-s/2,s,s);
      ctx.strokeStyle=neon; ctx.lineWidth=2; ctx.strokeRect(t.x-s/2+1,t.y-s/2+1,s-2,s-2);
      const tx=t.x+Math.cos(t.turret)*4, ty=t.y+Math.sin(t.turret)*4;
      ctx.fillStyle='#0e1f2e'; ctx.fillRect(tx-6,ty-6,12,12);
      ctx.strokeStyle=neon; ctx.lineWidth=2; ctx.strokeRect(tx-6,ty-6,12,12);
      ctx.strokeStyle=neon; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(t.x,t.y); ctx.lineTo(t.x+Math.cos(t.turret)*(s/2+14), t.y+Math.sin(t.turret)*(s/2+14)); ctx.stroke();
      ctx.fillStyle=neon; ctx.font='12px monospace'; ctx.fillText(t.name, t.x-ctx.measureText(t.name).width/2, t.y - s/2 - 8);
    }

    if(paused){ ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#fff'; ctx.font='24px monospace'; ctx.fillText('Duraklatıldı',canvas.width/2-70,canvas.height/2); }
    if(editorMode){ ctx.fillStyle='rgba(0,240,255,.15)'; ctx.fillRect(0,0,canvas.width,20); ctx.fillStyle='#00e5ff'; ctx.font='14px monospace'; ctx.fillText('EDITÖR: Sol tık duvar, R: mod, S: kaydet, X: temizle, G: ızgara',8,14); }
  }

  function hexToRgb(hex){ const v=hex.replace('#',''); const bigint=parseInt(v,16); const r=(bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255; return `${r},${g},${b}`; }

  let last=performance.now();
  function loop(t){ const dt=t-last; last=t; update(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  // ======= Input =======
  window.addEventListener('keydown',e=>{ keys.add(e.code); if(["KeyF","Semicolon"].includes(e.code)) e.preventDefault(); if(editorMode) onEditorKey(e); });
  window.addEventListener('keyup',e=>keys.delete(e.code));
  const mousePos=(e)=>{ const r=canvas.getBoundingClientRect(); return {x:e.clientX-r.left,y:e.clientY-r.top}; };
  canvas.addEventListener('mousemove',e=>{ const p=mousePos(e); mouse.x=p.x; mouse.y=p.y; });
  canvas.addEventListener('mousedown',e=>{
    const p=mousePos(e); const cx=Math.floor(p.x/TILE); const cy=Math.floor(p.y/TILE);
    if(editorMode){ if(cx>=0&&cx<COLS&&cy>=0&&cy<ROWS){ grid[cy][cx]=editorPaint?1:0; draw(); } return; }
    if(e.button===0){ mouse.down=true; const p1=tanks[0]; if(p1&&p1.alive&&p1.spawnTimer<=0&&p1.ammo>0){ p1.spawnTimer=FIRE_CD_MS; p1.ammo--; spawnBullet(0,p1.x,p1.y,p1.turret); }}
  });
  window.addEventListener('mouseup',e=>{ if(e.button===0) mouse.down=false; });
  canvas.addEventListener('mouseleave',()=>{ mouse.down=false; });

  // ======= UI wiring =======
  const $=sel=>document.querySelector(sel);
  const statusEl=$('#status');
  const scoreEl=$('#score');
  const ammoEl=$('#ammo');
  const mapSel=$('#mapSelect');

  function rebuildMapList(){ mapSel.innerHTML=""; const add=(name,custom)=>{const opt=document.createElement('option');opt.value=name;opt.textContent=custom?`${name} (özel)`:name;mapSel.appendChild(opt)}; Object.keys(MAPS).forEach(n=>add(n,false)); Object.keys(customMaps).forEach(n=>add(n,true)); mapSel.value=currentMapName; }

  $('#btnPlay').onclick=()=>{ editorMode=false; playing=true; paused=false; statusEl.textContent='Yerel VS'; resetGame(); };
  $('#btnEditor').onclick=()=>{ editorMode=true; playing=false; paused=false; statusEl.textContent='Editör'; draw(); };
  $('#btnPause').onclick=()=>{ if(!playing) return; paused=!paused; };
  $('#btnRestart').onclick=()=>{ if(playing) resetGame(); };
  $('#btnResetScores').onclick=()=>{ score=score.map(()=>0); updateScore(); };
  mapSel.onchange=()=>{ currentMapName=mapSel.value; if(playing) resetGame(); else { grid=copyGrid((MAPS[currentMapName]||customMaps[currentMapName])); draw(); } };

  const colorSelNew=document.getElementById('newPlayerColor'); COLORS.forEach(c=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; o.style.background=c; colorSelNew.appendChild(o); });
  document.getElementById('btnAddPlayer').onclick=()=>{ const n=(document.getElementById('newPlayerName').value||'Player').trim(); const c=colorSelNew.value||COLORS[0]; const list=document.getElementById('playersList'); if(list.children.length>=4){ alert('Maksimum 4 oyuncu'); return; } addPlayerUIRow(n,c); rebuildPlayersFromUI(); };

  const nameInput=document.getElementById('mapName');
  document.getElementById('btnSaveMap').onclick=()=>{ const name=(nameInput.value||'Özel Harita').trim(); if(!name) return; customMaps[name]=copyGrid(grid); saveCustomMaps(customMaps); currentMapName=name; rebuildMapList(); statusEl.textContent='Harita kaydedildi'; };
  document.getElementById('btnExport').onclick=()=>{ const data={name:currentMapName,grid}; const blob=new Blob([JSON.stringify(data)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(currentMapName||'map')+'.json'; a.click(); };
  document.getElementById('btnImport').onclick=()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json'; inp.onchange=()=>{ const f=inp.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ try{ const obj=JSON.parse(r.result); if(Array.isArray(obj.grid)){ grid=obj.grid; currentMapName=obj.name||'Imported'; customMaps[currentMapName]=copyGrid(grid); saveCustomMaps(customMaps); rebuildMapList(); statusEl.textContent='Harita içe aktarıldı'; draw(); } } catch{ alert('Geçersiz JSON'); } }; r.readAsText(f); }; inp.click(); };

  function onEditorKey(e){
    if(!editorMode) return;
    if(e.code==='KeyR'){ editorPaint=editorPaint?0:1; statusEl.textContent=editorPaint?'Editör: Duvar yerleştir':'Editör: Duvar sil'; e.preventDefault(); }
    if(e.code==='KeyS'){ const n=(nameInput.value||'Özel Harita').trim(); if(!n) return; customMaps[n]=copyGrid(grid); saveCustomMaps(customMaps); rebuildMapList(); statusEl.textContent='Harita kaydedildi'; e.preventDefault(); }
    if(e.code==='KeyX'){ grid=blankGrid(); statusEl.textContent='Harita temizlendi'; e.preventDefault(); }
    if(e.code==='KeyG'){ showGrid=!showGrid; statusEl.textContent=showGrid?'Izgara: Açık':'Izgara: Kapalı'; e.preventDefault(); }
    draw();
  }

  function init(){ rebuildMapList(); statusEl.textContent='Yerel VS'; resetGame(); updateScore(); draw(); }
  init();

  // ======= ODA / WebRTC (çoklu misafir, host authoritative) =======
  const roomOfferTA=document.getElementById('roomOffer');
  const roomAnswerTA=document.getElementById('roomAnswer');
  const roomNameI=document.getElementById('roomName');
  const roomPassI=document.getElementById('roomPass');

  let ROOM_NAME='', ROOM_PASS='', ROOM_KEY='';
  function djb2(str){ let h=5381; for(let i=0;i<str.length;i++){ h=((h<<5)+h) + str.charCodeAt(i); h|=0; } return (h>>>0).toString(16); }
  function computeRoomKey(name,pass){ return djb2((name||'')+'#'+(pass||'')); }

  async function createHostPeer(){
    if(hostPeers.length>=3){ alert('Maksimum 3 misafir (toplam 4 oyuncu)'); return null; }
    const slot = 1 + hostPeers.length; // 1..3 (P2..P4)
    const pc=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
    const dc=pc.createDataChannel('ptanks');
    dc.onopen=()=>{ statusEl.textContent='Host: Misafir bağlandı (slot '+(slot+1)+')'; };
    dc.onmessage=(ev)=>{ try{ const msg=JSON.parse(ev.data); if(msg.type==='input'){ if(tanks[slot]) tanks[slot]._remote=msg; } }catch{} };
    pc.onicecandidate=e=>{ if(!e.candidate){
      const payload={ desc: pc.localDescription, key: ROOM_KEY, name: ROOM_NAME, slot };
      roomOfferTA.value=btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
      statusEl.textContent='Oda Kodu hazır (slot '+(slot+1)+')';
    } };
    const offer=await pc.createOffer(); await pc.setLocalDescription(offer);
    hostPeers.push({pc,dc,slot});
    return {pc,dc,slot};
  }

  document.getElementById('btnRoomCreate').onclick=async()=>{
    ROOM_NAME=(roomNameI.value||''); ROOM_PASS=(roomPassI.value||''); ROOM_KEY=computeRoomKey(ROOM_NAME,ROOM_PASS);
    if(!ROOM_NAME){ alert('Oda adı gerekli'); return; }
    role='host'; statusEl.textContent='Host: Oda kuruluyor...'; await createHostPeer(); };

  document.getElementById('btnRoomAddGuest').onclick=async()=>{ if(role!=='host') { alert('Önce Oda Kur'); return; } await createHostPeer(); };
  document.getElementById('btnCopyRoom').onclick=()=>{ roomOfferTA.select(); document.execCommand('copy'); };
  document.getElementById('btnApplyAnswer').onclick=async()=>{
    if(role!=='host'){ alert('Host değilsiniz'); return; }
    const ansStr=roomAnswerTA.value.trim(); if(!ansStr) return;
    try{
      const wrapper=JSON.parse(decodeURIComponent(escape(atob(ansStr))));
      if(wrapper.key!==ROOM_KEY){ alert('Yanıt bu odaya ait değil (anahtar uyuşmuyor)'); return; }
      const target=hostPeers[hostPeers.length-1];
      await target.pc.setRemoteDescription(wrapper.desc);
      statusEl.textContent='Host: Yanıt uygulandı';
    }catch{ alert('Yanıt Kodu geçersiz'); }
  };

  document.getElementById('btnJoinRoom').onclick=()=>{ role='guest'; statusEl.textContent='Misafir: Oda adı + şifre girin; Oda Kodunu yapıştırın, Yanıt oluşturun.'; };
  document.getElementById('btnMakeAnswer').onclick=async()=>{
    if(role!=='guest'){ alert('Önce Odaya Katıl'); return; }
    try{
      const offerStr=roomOfferTA.value.trim(); if(!offerStr) return;
      const offerWrap=JSON.parse(decodeURIComponent(escape(atob(offerStr))));
      const gName=(roomNameI.value||''); const gPass=(roomPassI.value||''); const gKey=computeRoomKey(gName,gPass);
      if(!gName){ alert('Oda adı girin'); return; }
      if(offerWrap.key!==gKey){ alert('Oda adı/şifresi yanlış'); return; }
      guestPC=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
      guestPC.ondatachannel=e=>{ guestDC=e.channel; };
      guestPC.onicecandidate=e=>{ if(!e.candidate){
        const payload={ desc: guestPC.localDescription, key: gKey };
        roomAnswerTA.value=btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
        statusEl.textContent='Yanıt Kodu hazır';
      } };
      await guestPC.setRemoteDescription(offerWrap.desc);
      const ans=await guestPC.createAnswer(); await guestPC.setLocalDescription(ans);
      setInterval(()=>{ if(role==='guest' && guestDC && guestDC.readyState==='open'){ const payload={type:'input', keys:[...keys], mouse, fire:mouse.down}; try{ guestDC.send(JSON.stringify(payload)); }catch{} } }, 80);
    }catch{ alert('Oda Kodu geçersiz'); }
  };

  // ======= DEV TESTS (mevcutları koru + yenilerini ekle) =======
  (function runDevTests(){
    try{
      console.log('%c[TEST] grid boyutu','color:#00e5ff');
      console.assert(grid.length===ROWS && grid[0].length===COLS,'Grid boyutu hatalı');

      console.log('%c[TEST] oyuncu limiti','color:#00e5ff');
      const list=document.getElementById('playersList');
      addPlayerUIRow('P3',COLORS[2]); addPlayerUIRow('P4',COLORS[3]); addPlayerUIRow('P5',COLORS[4]);
      rebuildPlayersFromUI();
      console.assert(tanks.length>=2 && tanks.length<=4,'Oyuncu sayısı 2-4 aralığında değil');

      console.log('%c[TEST] spawn ammo = 3','color:#00e5ff');
      resetGame(); console.assert(tanks[0].ammo===3 && tanks[1].ammo===3,'Spawn ammo 3 değil');

      console.log('%c[TEST] ızgara toggle','color:#00e5ff');
      const sg=showGrid; onEditorKey({code:'KeyG',preventDefault:()=>{}}); console.assert(showGrid!==sg,'Izgara değişmedi');

      console.log('%c[TEST] bullet trail dynamics','color:#00e5ff');
      resetGame(); let p=tanks[0]; p.turret=0; p.ammo=5; spawnBullet(0,p.x,p.y,p.turret);
      for(let i=0;i<10;i++) update(16); const L0=bullets[0].trail.length;
      for(let i=0;i<100;i++) update(16); const L1=bullets[0].trail.length;
      bullets[0].x = TILE* (COLS-1); update(16); const L2=bullets[0].trail.length;
      console.assert(L0>15,'Trail should start long');
      console.assert(L1<L0,'Trail should get shorter over time');
      console.assert(L2>=L1,'Trail should extend on bounce');

      console.log('%c[TEST] spawn uzaklık','color:#00e5ff');
      resetGame();
      let ok=true; for(let i=0;i<tanks.length;i++){ for(let j=i+1;j<tanks.length;j++){ if(Math.hypot(tanks[i].x-tanks[j].x,tanks[i].y-tanks[j].y)<TILE*6) ok=false; }}
      console.assert(ok,'Spawnlar birbirine çok yakın');

      console.log('%c[TEST] canvas köşe','color:#00e5ff');
      console.assert(getComputedStyle(canvas).borderRadius==='0px','Canvas border-radius 0 değil');

      console.log('%c[TEST] guest no simulate','color:#00e5ff');
      const oldRole=role; role='guest'; const gx=tanks[0].x; update(1000); console.assert(tanks[0].x===gx,'Guest must not advance simulation'); role=oldRole;

      console.log('%c[TEST] room key hash','color:#00e5ff');
      const k1=computeRoomKey('oda','123'); const k2=computeRoomKey('oda','123'); const k3=computeRoomKey('oda','456');
      console.assert(k1===k2,'Key deterministic değil');
      console.assert(k1!==k3,'Farklı şifre farklı anahtar üretmeli');

    }catch(err){ console.error('Test hatası:',err); }
  })();

  </script>
</body>
</html>
