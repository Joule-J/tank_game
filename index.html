<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Tanks — TRON Neon</title>
  <style>
    :root{
      --bg1:#06070b; --bg2:#0a0f1e;
      --panel:#0a0f1e; --panel2:#0b1226;
      --text:#e6fbff; --muted:#7cc7d9; --acc:#00f0ff; --acc2:#00ffa3; --danger:#ff4d88; --ok:#00ffa3
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;
      color:var(--text); display:flex; background:radial-gradient(1200px 800px at 20% 10%, #0e2740 0%, #07101e 40%, #05070d 100%);
    }
    .sidebar{width:420px;max-width:100%;padding:16px;background:linear-gradient(180deg,var(--panel),var(--panel2));border-right:1px solid #0f2547;overflow:auto;box-shadow:inset -8px 0 24px rgba(0,240,255,.05)}
    .brand{font-weight:900;letter-spacing:.5px;font-size:20px;display:flex;align-items:center;gap:8px;text-shadow:0 0 8px rgba(0,240,255,.6)}
    .brand .dot{width:10px;height:10px;background:var(--acc);border-radius:2px;box-shadow:0 0 18px var(--acc)}
    .section{margin-top:16px;padding-top:12px;border-top:1px dashed rgba(0,240,255,.25)}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button,select,input[type="text"],textarea,.btn{
      background:#0b142b;color:var(--text);border:1px solid rgba(0,240,255,.3);padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:700;
      box-shadow:0 0 10px rgba(0,240,255,.08) inset, 0 0 8px rgba(0,240,255,.08);
    }
    textarea{width:100%;min-height:90px;resize:vertical}
    button:hover,.btn:hover{filter:brightness(1.15)}
    .btn-ghost{background:transparent;border:1px dashed rgba(0,240,255,.35);color:var(--muted)}
    .note{font-size:12px;color:var(--muted)}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#07101e;border:1px solid rgba(0,240,255,.25);padding:2px 6px;border-radius:6px;box-shadow:0 0 10px rgba(0,240,255,.08) inset}
    .swatch{width:18px;height:18px;border-radius:4px;border:1px solid rgba(255,255,255,.25);cursor:pointer;box-shadow:0 0 10px rgba(255,255,255,.08)}
    canvas{
      image-rendering:pixelated;background:linear-gradient(180deg,#02050a,#030812);
      border-radius:18px; box-shadow:0 0 40px rgba(0,240,255,.25), inset 0 0 24px rgba(0,240,255,.06); border:1px solid rgba(0,240,255,.25)
    }
    .main{flex:1;display:flex;padding:16px}
    .stage{margin:auto;display:flex;flex-direction:column;gap:8px;align-items:center}
    .bar{display:flex;gap:8px;align-items:center;justify-content:center;width:100%}
    .pill{background:#07101e;border:1px solid rgba(0,240,255,.35);padding:8px 12px;border-radius:999px;color:var(--text);font-size:13px;box-shadow:0 0 10px rgba(0,240,255,.08) inset}
    .grid-legend{display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:12px}
    .small{font-size:12px;color:var(--muted)}
    .ok{color:#b7ffcf}
    .players{display:flex;flex-direction:column;gap:8px}
    .playerRow{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <aside class="sidebar">
    <div class="brand"><span class="dot"></span> Pixel Tanks — <span style="color:var(--acc)">NEON</span></div>

    <div class="section">
      <h4>Oyuncular (2-8)</h4>
      <div class="players" id="playersList"></div>
      <div class="row">
        <input id="newPlayerName" type="text" placeholder="Oyuncu adı" />
        <select id="newPlayerColor"></select>
        <button id="btnAddPlayer">Oyuncu Ekle</button>
      </div>
      <p class="note">İlk iki oyuncu yerelde kontrol edilir (P1: WASD+Mouse, P2: IJKL/UO/;). Diğerleri ağ üzerinden katılabilir.</p>
    </div>

    <div class="section">
      <h4>Oyun Modu</h4>
      <div class="row">
        <button id="btnPlay">Yerel VS</button>
        <button id="btnEditor">Harita Editörü</button>
      </div>
      <p class="note">Çevrimiçi oynamak için WebRTC eşleştirme (kopyala‑yapıştır) kullanın.</p>
    </div>

    <div class="section">
      <h4>Harita Seç</h4>
      <div class="row">
        <select id="mapSelect"></select>
        <button id="btnResetScores" class="btn-ghost">Skorları Sıfırla</button>
      </div>
    </div>

    <div class="section">
      <h4>Kontroller</h4>
      <div class="grid-legend">
        <div><b>Oyuncu 1</b><br><span class="small"><span class="kbd">WASD</span> hareket • <b>Fare</b> nişan • <b>Sol tık</b> ateş</span></div>
        <div><b>Oyuncu 2</b><br><span class="small"><span class="kbd">IJKL</span> hareket • <span class="kbd">U/O</span> kule • <span class="kbd">;</span> ateş</span></div>
      </div>
      <p class="note">Mermi duvarlardan en fazla 2 kez seker. Dergi: 5 mermi, her eksik mermi <b>2.0s</b> sonra dolar. Doğuşta <b>3 mermi</b>.</p>
    </div>

    <div class="section">
      <h4>Editör</h4>
      <p class="small">Sol tık: duvar ekle/kaldır • <span class="kbd">R</span>: yerleştir/sil • <span class="kbd">S</span>: kaydet • <span class="kbd">X</span>: temizle • <span class="kbd">G</span>: ızgara aç/kapa</p>
      <div class="row">
        <input id="mapName" type="text" placeholder="Yeni harita adı" />
        <button id="btnSaveMap">Kaydet</button>
        <button id="btnExport" class="btn-ghost">Dışa Aktar</button>
        <button id="btnImport" class="btn-ghost">İçe Aktar</button>
      </div>
    </div>

    <div class="section">
      <h4>WebRTC (manuel)</h4>
      <div class="row">
        <button id="btnHost">Sunucu (Teklif oluştur)</button>
        <button id="btnJoin">Misafir (Teklifi gir)</button>
      </div>
      <div class="row">
        <textarea id="webrtcOffer" placeholder="Teklif (Offer)"></textarea>
        <textarea id="webrtcAnswer" placeholder="Yanıt (Answer)"></textarea>
      </div>
      <div class="row">
        <button id="btnCopyOffer" class="btn-ghost">Teklifi Kopyala</button>
        <button id="btnSetAnswer" class="btn-ghost">Yanıtı Uygula</button>
        <button id="btnMakeAnswer" class="btn-ghost">Yanıt Oluştur</button>
      </div>
      <p class="note">Host simülasyon yapar; misafirler giriş yollar. Her misafir bir oyuncudur.</p>
    </div>

  </aside>

  <main class="main">
    <div class="stage">
      <div class="bar">
        <span class="pill" id="status">Hazır</span>
        <span class="pill" id="score">—</span>
        <span class="pill" id="ammo">P1 Ammo: 3/5</span>
      </div>
      <canvas id="game" width="960" height="640"></canvas>
      <div class="bar">
        <button id="btnPause" class="btn">Duraklat</button>
        <button id="btnRestart" class="btn">Yeniden Başlat</button>
      </div>
    </div>
  </main>

  <script>
  // ======= Utility =======
  const TILE=32, COLS=30, ROWS=20;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now();
  function blankGrid(){return Array.from({length:ROWS},()=>Array(COLS).fill(0));}
  function copyGrid(g){return g.map(r=>r.slice())}

  // ======= Colors (8 seçenek) =======
  const COLORS=['#00FFA3','#00E5FF','#FF6EC7','#FFD166','#8AFF00','#FF4D88','#A78BFA','#00FFD1'];

  // ======= Maps =======
  const MAPS={
    "Boxed Arena":(()=>{const g=blankGrid();
      for(let x=0;x<COLS;x++){g[0][x]=1;g[ROWS-1][x]=1}
      for(let y=0;y<ROWS;y++){g[y][0]=1;g[y][COLS-1]=1}
      for(let x=10;x<20;x++) g[Math.floor(ROWS/2)][x]=1;
      for(let y=6;y<14;y++) g[y][Math.floor(COLS/2)]=1; return g;})(),
    "Corridors":(()=>{const g=blankGrid();
      for(let x=0;x<COLS;x++){g[0][x]=1;g[ROWS-1][x]=1}
      for(let y=0;y<ROWS;y++){g[y][0]=1;g[y][COLS-1]=1}
      for(let y=2;y<ROWS-2;y+=4){for(let x=2;x<COLS-2;x++) g[y][x]=1}
      for(let x=4;x<COLS-4;x+=6){for(let y=4;y<ROWS-4;y++) g[y][x]=1} return g;})(),
    "Islands":(()=>{const g=blankGrid();
      for(let x=0;x<COLS;x++){g[0][x]=1;g[ROWS-1][x]=1}
      for(let y=0;y<ROWS;y++){g[y][0]=1;g[y][COLS-1]=1}
      const blocks=[[6,5,4,3],[18,5,5,4],[10,12,6,3],[20,12,5,4]];
      for(const [sx,sy,w,h] of blocks){for(let y=sy;y<sy+h;y++){for(let x=sx;x<sx+w;x++){g[y][x]=1}}} return g;})()
  };

  function loadCustomMaps(){try{return JSON.parse(localStorage.getItem('pixelTanksMaps')||"{}");}catch{return {}}}
  function saveCustomMaps(obj){localStorage.setItem('pixelTanksMaps',JSON.stringify(obj))}

  // ======= Canvas =======
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');
  ctx.imageSmoothingEnabled=false;

  // ======= Game State =======
  let currentMapName=Object.keys(MAPS)[0];
  let customMaps=loadCustomMaps();
  let grid=copyGrid(MAPS[currentMapName]);
  let playing=true, paused=false;
  let keys=new Set();
  let bullets=[], tanks=[], score=[];
  let editorMode=false, editorPaint=1, showGrid=true;
  let mouse={x:canvas.width/2,y:canvas.height/2,down:false};

  // Networking (manual WebRTC)
  let role='solo'; // 'host' | 'guest' | 'solo'
  let pc=null, dc=null; // RTCPeerConnection, DataChannel

  const AMMO_MAX=5, AMMO_RELOAD_MS=2000, FIRE_CD_MS=250, RESPAWN_INV_MS=2000, RESPAWN_DELAY_MS=400, SPAWN_AMMO=3;

  function makeTank(color,x,y,angle,name){
    return{ name, color, x, y, angle, turret:angle, vx:0, vy:0, speed:2.2, size:24,
      alive:true, spawnTimer:0, ammo:SPAWN_AMMO, ammoAcc:0, invulnUntil:0 }
  }

  function setDefaultPlayers(){
    tanks=[
      makeTank(COLORS[0],TILE*2,TILE*2,0,'Player 1'),
      makeTank(COLORS[1],canvas.width-TILE*2,canvas.height-TILE*2,Math.PI,'Player 2')
    ];
    score=[0,0];
  }

  function addPlayerUIRow(name="Player", color=COLORS[ (Math.random()*COLORS.length)|0 ]){
    const list=document.getElementById('playersList');
    const row=document.createElement('div'); row.className='playerRow';
    const nameI=document.createElement('input'); nameI.type='text'; nameI.value=name; nameI.placeholder='Oyuncu adı';
    const colorSel=document.createElement('select');
    COLORS.forEach((c,i)=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; o.style.background=c; if(c===color) o.selected=true; colorSel.appendChild(o); });
    const btnDel=document.createElement('button'); btnDel.textContent='Sil';
    row.appendChild(nameI); row.appendChild(colorSel); row.appendChild(btnDel); list.appendChild(row);
    btnDel.onclick=()=>{ list.removeChild(row); rebuildPlayersFromUI(); };
    nameI.onchange=colorSel.onchange=()=>rebuildPlayersFromUI();
  }

  function rebuildPlayersFromUI(){
    const list=document.getElementById('playersList');
    const rows=[...list.querySelectorAll('.playerRow')];
    if(rows.length<2){ while(rows.length<2){ addPlayerUIRow('Player '+(rows.length+1), COLORS[rows.length%COLORS.length]); rows.push(...list.querySelectorAll('.playerRow')); } }
    // reset players but keep positions if possible
    const old=tanks; tanks=[]; score=[];
    rows.forEach((r,idx)=>{
      const name=r.querySelector('input').value||('Player '+(idx+1));
      const color=r.querySelector('select').value||COLORS[idx%COLORS.length];
      const pos = idx===0? {x:TILE*2,y:TILE*2,angle:0} : idx===1? {x:canvas.width-TILE*2,y:canvas.height-TILE*2,angle:Math.PI} : {x:(2+idx)%COLS*TILE, y:(2+idx)%ROWS*TILE, angle:0};
      const t=makeTank(color,pos.x,pos.y,pos.angle,name);
      tanks.push(t); score.push(0);
    });
    updateScore(); draw();
  }

  // initial players UI
  (function initPlayersUI(){ addPlayerUIRow('Player 1', COLORS[0]); addPlayerUIRow('Player 2', COLORS[1]); })();

  function resetGame(){
    grid=copyGrid((MAPS[currentMapName]||customMaps[currentMapName]));
    bullets=[];
    if(document.getElementById('playersList').children.length<2){ setDefaultPlayers(); } else { rebuildPlayersFromUI(); }
    tanks.forEach(t=>{ t.alive=true; t.invulnUntil=0; t.ammo=SPAWN_AMMO; t.ammoAcc=0; });
    updateHud();
  }

  function aabbWall(x,y,sz){
    const left=Math.floor((x-sz/2)/TILE), right=Math.floor((x+sz/2)/TILE);
    const top=Math.floor((y-sz/2)/TILE), bottom=Math.floor((y+sz/2)/TILE);
    for(let ty=top;ty<=bottom;ty++){
      for(let tx=left;tx<=right;tx++){
        if(ty<0||ty>=ROWS||tx<0||tx>=COLS) return {hit:true,tx,ty};
        if(grid[ty][tx]===1) return {hit:true,tx,ty};
      }
    }
    return {hit:false};
  }

  function spawnBullet(ownerIdx,x,y,dir){
    bullets.push({
      owner:ownerIdx, x, y,
      vx:Math.cos(dir)*5, vy:Math.sin(dir)*5,
      bounces:0, maxB:2, alive:true,
      // dynamic trail state
      trail:[], age:0,
      trailMin:8, trailBase:12, trailInitial:28, // spawn: long
      bounceBoost:0, bounceBoostMax:500, // ms
    });
  }

  function farthestCornerFrom(px,py){
    const corners=[[TILE*2,TILE*2],[canvas.width-TILE*2,TILE*2],[TILE*2,canvas.height-TILE*2],[canvas.width-TILE*2,canvas.height-TILE*2]];
    let best=corners[0], bd=-1; for(const c of corners){ const d=Math.hypot(px-c[0],py-c[1]); if(d>bd){bd=d; best=c} } return {x:best[0],y:best[1]};
  }

  function handleKill(killerIdx,victimIdx){
    const killer=tanks[killerIdx], victim=tanks[victimIdx];
    if(!victim || !victim.alive) return;
    victim.alive=false; bullets.forEach(b=>{ if(b.owner===victimIdx) b.alive=false; });
    score[killerIdx] = (score[killerIdx]||0)+1; updateScore();
    setTimeout(()=>{
      const other=tanks[killerIdx]; const pos=farthestCornerFrom(other.x,other.y);
      Object.assign(victim,{x:pos.x,y:pos.y,alive:true,spawnTimer:FIRE_CD_MS*2,invulnUntil:now()+RESPAWN_INV_MS,ammo:SPAWN_AMMO,ammoAcc:0});
      updateHud();
    }, RESPAWN_DELAY_MS);
  }

  function update(dt){
    if(!playing||paused) return;
    const p1=tanks[0], p2=tanks[1];

    // --- P1: WASD + Mouse aim/Left click fire
    if(p1&&p1.alive){
      const ax=(keys.has('KeyD')?1:0)-(keys.has('KeyA')?1:0);
      const ay=(keys.has('KeyS')?1:0)-(keys.has('KeyW')?1:0);
      const mag=Math.hypot(ax,ay), nx=mag?ax/mag:0, ny=mag?ay/mag:0;
      p1.vx=nx*p1.speed; p1.vy=ny*p1.speed;
      p1.x+=p1.vx; if(aabbWall(p1.x,p1.y,p1.size).hit) p1.x-=p1.vx;
      p1.y+=p1.vy; if(aabbWall(p1.x,p1.y,p1.size).hit) p1.y-=p1.vy;
      p1.turret=Math.atan2(mouse.y-p1.y,mouse.x-p1.x);
      p1.spawnTimer=Math.max(0,p1.spawnTimer-dt);
      if(p1.ammo<AMMO_MAX){ p1.ammoAcc+=dt; while(p1.ammo<AMMO_MAX && p1.ammoAcc>=AMMO_RELOAD_MS){ p1.ammo++; p1.ammoAcc-=AMMO_RELOAD_MS; } }
      if(mouse.down && p1.spawnTimer<=0 && p1.ammo>0){ p1.spawnTimer=FIRE_CD_MS; p1.ammo--; spawnBullet(0,p1.x,p1.y,p1.turret); }
    }

    // --- P2: IJKL move, U/O turret, ; fire
    if(p2&&p2.alive){
      const ax=(keys.has('KeyL')?1:0)-(keys.has('KeyJ')?1:0);
      const ay=(keys.has('KeyK')?1:0)-(keys.has('KeyI')?1:0);
      const mag=Math.hypot(ax,ay), nx=mag?ax/mag:0, ny=mag?ay/mag:0;
      p2.vx=nx*p2.speed; p2.vy=ny*p2.speed;
      p2.x+=p2.vx; if(aabbWall(p2.x,p2.y,p2.size).hit) p2.x-=p2.vx;
      p2.y+=p2.vy; if(aabbWall(p2.x,p2.y,p2.size).hit) p2.y-=p2.vy;
      if(keys.has('KeyU')) p2.turret-=0.05; if(keys.has('KeyO')) p2.turret+=0.05;
      p2.spawnTimer=Math.max(0,p2.spawnTimer-dt);
      if(p2.ammo<AMMO_MAX){ p2.ammoAcc+=dt; while(p2.ammo<AMMO_MAX && p2.ammoAcc>=AMMO_RELOAD_MS){ p2.ammo++; p2.ammoAcc-=AMMO_RELOAD_MS; } }
      if(keys.has('Semicolon') && p2.spawnTimer<=0 && p2.ammo>0){ p2.spawnTimer=FIRE_CD_MS; p2.ammo--; spawnBullet(1,p2.x,p2.y,p2.turret); }
    }

    // --- Bullets + dynamic TRON trail
    for(const b of bullets){ if(!b.alive) continue;
      // age & dynamic trail target length
      b.age += dt;
      const t = Math.min(1, Math.max(0, b.age/900)); // 0..1 over 0.9s
      const easeOut = 1 - (1 - t) * (1 - t);
      let trailTarget = b.trailInitial * (1 - easeOut) + b.trailBase * easeOut; // long→short
      if(b.bounceBoost>0){
        const k = b.bounceBoost / b.bounceBoostMax; // 1..0
        trailTarget += 12 * k; // bounce extend
        b.bounceBoost -= dt;
      }
      // clamp target
      trailTarget = Math.max(b.trailMin, Math.min(32, trailTarget));

      // trail log (cap by current target)
      b.trail.push({x:b.x,y:b.y});
      while(b.trail.length > Math.floor(trailTarget)) b.trail.shift();

      // move
      b.x+=b.vx; b.y+=b.vy;
      const cx=Math.floor(b.x/TILE), cy=Math.floor(b.y/TILE);
      if(cy<0||cy>=ROWS||cx<0||cx>=COLS||grid[cy][cx]===1){
        const prevX=b.x-b.vx, prevY=b.y-b.vy;
        const cellX=Math.floor(prevX/TILE), cellY=Math.floor(prevY/TILE);
        const hitX=(cellY<0||cellY>=ROWS||cx<0||cx>=COLS||grid[cellY][cx]===1);
        const hitY=(cy<0||cy>=ROWS||cellX<0||cellX>=COLS||grid[cy][cellX]===1);
        if(hitX) b.vx*=-1; if(hitY) b.vy*=-1;
        b.bounces++;
        if(b.bounces>b.maxB){ b.alive=false; continue }
        // on bounce: re-extend trail
        b.bounceBoost = b.bounceBoostMax;
        b.trailInitial = Math.min(30, Math.max(b.trailInitial, b.trailBase + 10));
        b.x=prevX+b.vx*0.5; b.y=prevY+b.vy*0.5;
      }
      for(let i=0;i<tanks.length;i++){
        const tnk=tanks[i]; if(!tnk||!tnk.alive||i===b.owner) continue; if(now()<tnk.invulnUntil) continue;
        if(Math.hypot(b.x-tnk.x,b.y-tnk.y)<tnk.size*0.55){ b.alive=false; handleKill(b.owner,i); }
      }
    }
    bullets=bullets.filter(b=>b.alive);

    // network tick (host authoritative) — sadece ilk 2 oyuncu için basit senkron
    if(role==='host' && dc && dc.readyState==='open' && tanks.length>=2){
      const state={type:'state',
        t:[0,1].map(i=>({x:tanks[i].x,y:tanks[i].y,turret:tanks[i].turret,alive:tanks[i].alive,inv:tanks[i].invulnUntil,ammo:tanks[i].ammo})),
        s:score, n:tanks.slice(0,2).map(t=>t.name) };
      try{ dc.send(JSON.stringify(state)); }catch{}
    }

    updateHud();
  }

  function updateScore(){
    const parts=tanks.map((t,i)=>`${t.name} ${score[i]||0}`).join('  •  ');
    scoreEl.textContent=parts||'—';
  }
  function updateHud(){ ammoEl.textContent=`P1 Ammo: ${tanks[0]?tanks[0].ammo:0}/${AMMO_MAX}`; }

  function draw(){
    // bg
    ctx.fillStyle='#03060d'; ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<canvas.height;y+=4){ ctx.fillStyle='rgba(0,240,255,0.03)'; ctx.fillRect(0,y,canvas.width,1); }

    // grid & walls
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const px=x*TILE, py=y*TILE;
        if(grid[y][x]===1){
          ctx.fillStyle='rgba(0,240,255,0.14)'; ctx.fillRect(px-2,py-2,TILE+4,TILE+4);
          ctx.fillStyle='#082238'; ctx.fillRect(px,py,TILE,TILE);
          ctx.strokeStyle='rgba(0,240,255,0.7)'; ctx.lineWidth=2; ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
        } else if(showGrid){
          ctx.fillStyle='rgba(0,240,255,0.05)'; ctx.fillRect(px,py,TILE,1); ctx.fillRect(px,py,1,TILE);
        }
      }
    }

    // bullet trails (TRON light — dynamic, pulsing)
    for(const b of bullets){
      const owner=tanks[b.owner]; const neon=owner?owner.color:'#00f0ff';
      const rgb=hexToRgb(neon);
      // draw from oldest→newest with alpha & width modulation
      for(let i=0;i<b.trail.length-1;i++){
        const p=b.trail[i], q=b.trail[i+1];
        const a=i/(b.trail.length-1); // 0..1 along trail
        const pulse = 0.6 + 0.4*Math.sin((b.age/90) + i*0.3); // slight motion
        const alpha = 0.08 + 0.28*a*pulse; // fade towards bullet
        ctx.strokeStyle=`rgba(${rgb},${alpha})`;
        ctx.lineWidth=1 + 2.5*(1-a)*pulse; // thicker near bullet, animates
        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
      }
    }

    // bullets cores
    for(const b of bullets){ const owner=tanks[b.owner]; const neon=owner?owner.color:'#00f0ff';
      ctx.fillStyle=`rgba(${hexToRgb(neon)},0.4)`; ctx.beginPath(); ctx.arc(b.x,b.y,6,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=neon; ctx.fillRect(b.x-2,b.y-2,4,4);
    }

    // tanks
    for(let idx=0; idx<tanks.length; idx++){
      const t=tanks[idx]; if(!t.alive) continue; const s=t.size; const blinking=(now()<t.invulnUntil)&&Math.floor(now()/150)%2===0;
      const neon=t.color; const glow = blinking? 'rgba(255,255,255,0.25)' : `${neon}80`;
      // glow base
      ctx.fillStyle=glow; ctx.fillRect(t.x-s/2-4,t.y-s/2-4,s+8,s+8);
      // core body
      ctx.fillStyle='#06101c'; ctx.fillRect(t.x-s/2,t.y-s/2,s,s);
      // neon outline
      ctx.strokeStyle=neon; ctx.lineWidth=2; ctx.strokeRect(t.x-s/2+1,t.y-s/2+1,s-2,s-2);
      // turret
      const tx=t.x+Math.cos(t.turret)*4, ty=t.y+Math.sin(t.turret)*4;
      ctx.fillStyle='#0e1f2e'; ctx.fillRect(tx-6,ty-6,12,12);
      ctx.strokeStyle=neon; ctx.lineWidth=2; ctx.strokeRect(tx-6,ty-6,12,12);
      ctx.strokeStyle=neon; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(t.x,t.y); ctx.lineTo(t.x+Math.cos(t.turret)*(s/2+14), t.y+Math.sin(t.turret)*(s/2+14)); ctx.stroke();
      // name
      ctx.fillStyle=neon; ctx.font='12px monospace'; ctx.fillText(t.name, t.x-ctx.measureText(t.name).width/2, t.y - s/2 - 8);
    }

    if(paused){ ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#fff'; ctx.font='24px monospace'; ctx.fillText('Duraklatıldı',canvas.width/2-70,canvas.height/2); }
    if(editorMode){ ctx.fillStyle='rgba(0,240,255,.15)'; ctx.fillRect(0,0,canvas.width,20); ctx.fillStyle='#00e5ff'; ctx.font='14px monospace'; ctx.fillText('EDITÖR: Sol tık duvar, R: mod, S: kaydet, X: temizle, G: ızgara',8,14); }
  }

  function hexToRgb(hex){
    const v=hex.replace('#',''); const bigint=parseInt(v,16);
    const r=(bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255; return `${r},${g},${b}`;
  }

  let last=performance.now();
  function loop(t){ const dt=t-last; last=t; update(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  // ======= Input =======
  window.addEventListener('keydown',e=>{ keys.add(e.code); if(["KeyF","Semicolon"].includes(e.code)) e.preventDefault(); if(editorMode) onEditorKey(e); });
  window.addEventListener('keyup',e=>keys.delete(e.code));

  const mousePos=(e)=>{ const r=canvas.getBoundingClientRect(); return {x:e.clientX-r.left,y:e.clientY-r.top}; };
  canvas.addEventListener('mousemove',e=>{ const p=mousePos(e); mouse.x=p.x; mouse.y=p.y; });
  canvas.addEventListener('mousedown',e=>{
    const p=mousePos(e); const cx=Math.floor(p.x/TILE); const cy=Math.floor(p.y/TILE);
    if(editorMode){ if(cx>=0&&cx<COLS&&cy>=0&&cy<ROWS){ grid[cy][cx]=editorPaint?1:0; draw(); } return; }
    if(e.button===0){ mouse.down=true; const p1=tanks[0]; if(p1&&p1.alive&&p1.spawnTimer<=0&&p1.ammo>0){ p1.spawnTimer=FIRE_CD_MS; p1.ammo--; spawnBullet(0,p1.x,p1.y,p1.turret); }}
  });
  window.addEventListener('mouseup',e=>{ if(e.button===0) mouse.down=false; });
  canvas.addEventListener('mouseleave',()=>{ mouse.down=false; });

  // ======= UI wiring =======
  const $=sel=>document.querySelector(sel);
  const statusEl=$('#status');
  const scoreEl=$('#score');
  const ammoEl=$('#ammo');
  const mapSel=$('#mapSelect');

  function rebuildMapList(){ mapSel.innerHTML=""; const add=(name,custom)=>{const opt=document.createElement('option');opt.value=name;opt.textContent=custom?`${name} (özel)`:name;mapSel.appendChild(opt)}; Object.keys(MAPS).forEach(n=>add(n,false)); Object.keys(customMaps).forEach(n=>add(n,true)); mapSel.value=currentMapName; }

  $('#btnPlay').onclick=()=>{ editorMode=false; playing=true; paused=false; statusEl.textContent='Yerel VS'; resetGame(); };
  $('#btnEditor').onclick=()=>{ editorMode=true; playing=false; paused=false; statusEl.textContent='Editör'; draw(); };
  $('#btnPause').onclick=()=>{ if(!playing) return; paused=!paused; };
  $('#btnRestart').onclick=()=>{ if(playing) resetGame(); };
  $('#btnResetScores').onclick=()=>{ score=score.map(()=>0); updateScore(); };
  mapSel.onchange=()=>{ currentMapName=mapSel.value; if(playing) resetGame(); else { grid=copyGrid((MAPS[currentMapName]||customMaps[currentMapName])); draw(); } };

  // players UI
  const colorSelNew=document.getElementById('newPlayerColor'); COLORS.forEach(c=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; o.style.background=c; colorSelNew.appendChild(o); });
  document.getElementById('btnAddPlayer').onclick=()=>{ const n=(document.getElementById('newPlayerName').value||'Player').trim(); const c=colorSelNew.value||COLORS[0]; const list=document.getElementById('playersList'); if(list.children.length>=8){ alert('Maksimum 8 oyuncu'); return; } addPlayerUIRow(n,c); rebuildPlayersFromUI(); };

  // editor hotkeys (fix: draw + status)
  const nameInput=document.getElementById('mapName');
  document.getElementById('btnSaveMap').onclick=()=>{ const name=(nameInput.value||'Özel Harita').trim(); if(!name) return; customMaps[name]=copyGrid(grid); saveCustomMaps(customMaps); currentMapName=name; rebuildMapList(); statusEl.textContent='Harita kaydedildi'; };
  document.getElementById('btnExport').onclick=()=>{ const data={name:currentMapName,grid}; const blob=new Blob([JSON.stringify(data)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(currentMapName||'map')+'.json'; a.click(); };
  document.getElementById('btnImport').onclick=()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json'; inp.onchange=()=>{ const f=inp.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ try{ const obj=JSON.parse(r.result); if(Array.isArray(obj.grid)){ grid=obj.grid; currentMapName=obj.name||'Imported'; customMaps[currentMapName]=copyGrid(grid); saveCustomMaps(customMaps); rebuildMapList(); statusEl.textContent='Harita içe aktarıldı'; draw(); } } catch{ alert('Geçersiz JSON'); } }; r.readAsText(f); }; inp.click(); };

  function onEditorKey(e){
    if(!editorMode) return;
    if(e.code==='KeyR'){ editorPaint=editorPaint?0:1; statusEl.textContent=editorPaint?'Editör: Duvar yerleştir':'Editör: Duvar sil'; e.preventDefault(); }
    if(e.code==='KeyS'){ const n=(nameInput.value||'Özel Harita').trim(); if(!n) return; customMaps[n]=copyGrid(grid); saveCustomMaps(customMaps); rebuildMapList(); statusEl.textContent='Harita kaydedildi'; e.preventDefault(); }
    if(e.code==='KeyX'){ grid=blankGrid(); statusEl.textContent='Harita temizlendi'; e.preventDefault(); }
    if(e.code==='KeyG'){ showGrid=!showGrid; statusEl.textContent=showGrid?'Izgara: Açık':'Izgara: Kapalı'; e.preventDefault(); }
    draw();
  }

  function init(){ rebuildMapList(); statusEl.textContent='Yerel VS'; resetGame(); updateScore(); draw(); }
  init();

  // ======= WebRTC (manual) =======
  const offerTA=document.getElementById('webrtcOffer');
  const answerTA=document.getElementById('webrtcAnswer');
  document.getElementById('btnHost').onclick=async()=>{
    role='host'; statusEl.textContent='Host: teklif oluşturuluyor...';
    pc=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
    dc=pc.createDataChannel('ptanks'); wireDataChannel();
    pc.onicecandidate=e=>{ if(!e.candidate){ offerTA.value=JSON.stringify(pc.localDescription); statusEl.textContent='Host: Teklif hazır; misafire gönderin.'; } };
    const offer=await pc.createOffer(); await pc.setLocalDescription(offer);
  };
  document.getElementById('btnCopyOffer').onclick=()=>{ offerTA.select(); document.execCommand('copy'); };
  document.getElementById('btnSetAnswer').onclick=async()=>{
    if(!pc) return; try{ const ans=JSON.parse(answerTA.value); await pc.setRemoteDescription(ans); statusEl.textContent='Host: Yanıt uygulandı, bağlanıyor...'; }catch(err){ alert('Yanıt JSON değil'); }
  };
  document.getElementById('btnJoin').onclick=async()=>{
    role='guest'; statusEl.textContent='Misafir: Teklifi yapıştırın ve Yanıt oluşturun';
    pc=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
    pc.ondatachannel=e=>{ dc=e.channel; wireDataChannel(); };
    pc.onicecandidate=e=>{ if(!e.candidate){ answerTA.value=JSON.stringify(pc.localDescription); statusEl.textContent='Misafir: Yanıt hazır; hosta gönderin.'; } };
  };
  document.getElementById('btnMakeAnswer').onclick=async()=>{
    if(!pc) return; try{ const off=JSON.parse(offerTA.value); await pc.setRemoteDescription(off); const ans=await pc.createAnswer(); await pc.setLocalDescription(ans); }catch(err){ alert('Teklif JSON değil'); }
  };

  function wireDataChannel(){ if(!dc) return; dc.onopen=()=>{ statusEl.textContent=(role==='host'?'Host':'Misafir')+': Bağlandı'; }; dc.onmessage=(ev)=>{ try{ const msg=JSON.parse(ev.data); if(role==='host') onGuestMsg(msg); else onHostMsg(msg); }catch{} }; }
  function onGuestMsg(msg){ if(msg.type==='input'){ const remoteIndex=1; /* basit: misafir P2 */ const p=tanks[remoteIndex]; if(p) p._remote=msg; } }
  function onHostMsg(msg){ if(msg.type==='state' && tanks.length>=2){ const t=msg.t; Object.assign(tanks[0],{x:t[0].x,y:t[0].y,turret:t[0].turret,alive:t[0].alive,invulnUntil:t[0].inv,ammo:t[0].ammo}); Object.assign(tanks[1],{x:t[1].x,y:t[1].y,turret:t[1].turret,alive:t[1].alive,invulnUntil:t[1].inv,ammo:t[1].ammo}); score=msg.s; updateScore(); } }
  setInterval(()=>{ if(role==='guest' && dc && dc.readyState==='open'){ const payload={type:'input', keys:[...keys], mouse, fire:mouse.down}; try{ dc.send(JSON.stringify(payload)); }catch{} } }, 80);

  // ======= DEV TESTS =======
  (function runDevTests(){
    try{
      console.log('%c[TEST] grid boyutu','color:#00e5ff');
      console.assert(grid.length===ROWS && grid[0].length===COLS,'Grid boyutu hatalı');

      console.log('%c[TEST] oyuncu limiti','color:#00e5ff');
      const list=document.getElementById('playersList'); const before=list.children.length; addPlayerUIRow('P3',COLORS[2]); addPlayerUIRow('P4',COLORS[3]); rebuildPlayersFromUI(); console.assert(tanks.length>=2,'En az 2 oyuncu yok');

      console.log('%c[TEST] spawn ammo = 3','color:#00e5ff');
      resetGame(); console.assert(tanks[0].ammo===3 && tanks[1].ammo===3,'Spawn ammo 3 değil');

      console.log('%c[TEST] ızgara toggle','color:#00e5ff');
      const sg=showGrid; onEditorKey({code:'KeyG',preventDefault:()=>{}}); console.assert(showGrid!==sg,'Izgara değişmedi');

      console.log('%c[TEST] bullet trail dynamics','color:#00e5ff');
      let prevLen;
      resetGame(); const p=tanks[0]; p.turret=0; p.ammo=5; spawnBullet(0,p.x,p.y,p.turret);
      for(let i=0;i<10;i++) update(16); const L0=bullets[0].trail.length; // initial long
      for(let i=0;i<100;i++) update(16); const L1=bullets[0].trail.length; // should decay shorter
      // simulate a bounce
      bullets[0].x = TILE* (COLS-1); update(16); const L2=bullets[0].trail.length; // after bounce extend
      console.assert(L0>15,'Trail should start long');
      console.assert(L1<L0,'Trail should get shorter over time');
      console.assert(L2>=L1,'Trail should extend on bounce');
      const p1=tanks[0]; p1.turret=0; p1.ammo=5; spawnBullet(0,p1.x,p1.y,p1.turret); for(let i=0;i<10;i++) update(16); console.assert(bullets[0].trail && bullets[0].trail.length>0,'Trail oluşmadı');

    }catch(err){ console.error('Test hatası:',err); }
  })();

  </script>
</body>
</html>
